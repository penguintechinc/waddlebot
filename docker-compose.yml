# WaddleBot Docker Compose - Unified Configuration
# Secure network isolation: internal services not exposed to host

networks:
  # Public network - services exposed to host
  waddlebot-public:
    driver: bridge

  # Internal network - database, redis, inter-service communication
  waddlebot-internal:
    driver: bridge
    internal: true

volumes:
  postgres-data:
  postgres-replica-data:
  redis-data:
  rabbitmq-data:
  minio-data:
  ollama-data:
  qdrant-data:

services:
  # =============================================================================
  # INFRASTRUCTURE SERVICES (Internal Only - NOT exposed to host)
  # =============================================================================

  infra-postgres:
    image: postgres:15-bookworm
    container_name: infra-postgres
    environment:
      POSTGRES_USER: waddlebot
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: waddlebot
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=C"
      # Allow replication connections from any host on the internal network
      POSTGRES_HOST_AUTH_METHOD: scram-sha-256
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./config/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql:ro
      - ./config/postgres/performance.conf:/etc/postgresql/performance.conf:ro
      - ./config/postgres/replication.conf:/etc/postgresql/replication.conf:ro
      - ./config/postgres/pg_hba.conf:/var/lib/postgresql/pg_hba.conf:ro
    command:
      - postgres
      - -c
      - hba_file=/var/lib/postgresql/pg_hba.conf
      - -c
      - wal_level=replica
      - -c
      - max_wal_senders=10
      - -c
      - max_replication_slots=10
      - -c
      - hot_standby=on
      - -c
      - max_connections=400
      - -c
      - listen_addresses=*
    networks:
      - waddlebot-internal
    # NO ports exposed - internal only
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U waddlebot"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # PostgreSQL Read Replica - routes SELECT queries here to reduce primary load
  infra-postgres-replica:
    image: postgres:15-bookworm
    container_name: infra-postgres-replica
    user: postgres
    environment:
      POSTGRES_USER: waddlebot
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: waddlebot
      PGUSER: waddlebot
      PGPASSWORD: ${POSTGRES_PASSWORD}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres-replica-data:/var/lib/postgresql/data
      - ./config/postgres/performance.conf:/etc/postgresql/performance.conf:ro
    entrypoint: /bin/bash
    command:
      - -c
      - |
        set -e

        # Wait for primary to be ready
        until pg_isready -h infra-postgres -p 5432 -U waddlebot 2>/dev/null; do
          echo "Waiting for primary postgres..."
          sleep 2
        done
        echo "Primary is ready!"

        # If replica data doesn't exist, create base backup from primary
        if [ ! -f "$${PGDATA}/PG_VERSION" ]; then
          echo "Creating base backup from primary..."
          mkdir -p "$${PGDATA}"
          rm -rf "$${PGDATA}"/*
          PGPASSWORD="$${POSTGRES_PASSWORD}" pg_basebackup -h infra-postgres -p 5432 -U waddlebot -D "$${PGDATA}" -Fp -Xs -P -R
          chmod 700 "$${PGDATA}"
          echo "Base backup complete!"
        fi

        # Start postgres in standby mode
        exec postgres -D "$${PGDATA}" -c hot_standby=on -c max_connections=400
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U waddlebot"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 60s
    restart: unless-stopped

  infra-redis:
    image: redis:7-bookworm
    container_name: infra-redis
    entrypoint: ["/usr/local/bin/docker-entrypoint.sh"]
    environment:
      # Admin password for maintenance
      REDIS_ADMIN_PASSWORD: ${REDIS_ADMIN_PASSWORD}
      # Per-module passwords (use secure passwords in production!)
      REDIS_ROUTER_PASSWORD: ${REDIS_ROUTER_PASSWORD}
      REDIS_HUB_PASSWORD: ${REDIS_HUB_PASSWORD}
      REDIS_WORKFLOW_PASSWORD: ${REDIS_WORKFLOW_PASSWORD}
      REDIS_AI_PASSWORD: ${REDIS_AI_PASSWORD}
      REDIS_ANALYTICS_PASSWORD: ${REDIS_ANALYTICS_PASSWORD}
      REDIS_SECURITY_PASSWORD: ${REDIS_SECURITY_PASSWORD}
      REDIS_LOYALTY_PASSWORD: ${REDIS_LOYALTY_PASSWORD}
      REDIS_SPOTIFY_PASSWORD: ${REDIS_SPOTIFY_PASSWORD}
      REDIS_YTMUSIC_PASSWORD: ${REDIS_YTMUSIC_PASSWORD}
      REDIS_TWITCH_PASSWORD: ${REDIS_TWITCH_PASSWORD}
      REDIS_DISCORD_PASSWORD: ${REDIS_DISCORD_PASSWORD}
      REDIS_SLACK_PASSWORD: ${REDIS_SLACK_PASSWORD}
    volumes:
      - redis-data:/data
      - ./config/redis/redis.conf:/etc/redis/redis.conf:ro
      - ./config/redis/users.acl:/etc/redis/users.acl.template:ro
      - ./config/redis/docker-entrypoint.sh:/usr/local/bin/docker-entrypoint.sh:ro
    networks:
      - waddlebot-internal
    # NO ports exposed - internal only
    healthcheck:
      test: ["CMD", "redis-cli", "-u", "redis://admin:${REDIS_ADMIN_PASSWORD}@localhost:6379", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  infra-minio:
    image: minio/minio:RELEASE.2024-01-16T16-07-38Z
    container_name: infra-minio
    ports:
      - "9000:9000"   # MinIO API
      - "9001:9001"   # MinIO Console
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
      MINIO_DOMAIN: localhost
    volumes:
      - minio-data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "mc", "ready", "local"]
      interval: 30s
      timeout: 20s
      retries: 3
    networks:
      - waddlebot-internal
      - waddlebot-public
    restart: unless-stopped

  # Ollama for local AI inference - auto-pulls tinyllama model on startup
  # For GPU support: docker compose --profile gpu up -d
  ai-ollama:
    image: ollama/ollama:latest
    container_name: ai-ollama
    volumes:
      - ollama-data:/root/.ollama
    networks:
      - waddlebot-internal
      - waddlebot-public  # Needs internet to pull models
    environment:
      OLLAMA_HOST: 0.0.0.0
    healthcheck:
      test: ["CMD", "ollama", "list"]
      interval: 30s
      timeout: 10s
      start_period: 120s
      retries: 5
    restart: unless-stopped

  # Ollama with GPU - use with: docker compose --profile gpu up -d
  # Requires nvidia-container-toolkit to be installed
  ai-ollama-gpu:
    image: ollama/ollama:latest
    container_name: ai-ollama-gpu
    profiles:
      - gpu
    volumes:
      - ollama-data:/root/.ollama
    networks:
      - waddlebot-internal
      - waddlebot-public
    environment:
      OLLAMA_HOST: 0.0.0.0
      NVIDIA_VISIBLE_DEVICES: all
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: all
              capabilities: [gpu]
    healthcheck:
      test: ["CMD", "ollama", "list"]
      interval: 30s
      timeout: 10s
      start_period: 120s
      retries: 5
    restart: unless-stopped

  # Ollama model puller - pulls tinyllama on first startup
  ai-ollama-pull:
    image: ollama/ollama:latest
    container_name: ai-ollama-pull
    volumes:
      - ollama-data:/root/.ollama
    networks:
      - waddlebot-internal
    environment:
      OLLAMA_HOST: http://ai-ollama:11434
    entrypoint: /bin/sh
    command:
      - -c
      - |
        echo "Waiting for Ollama server..."
        sleep 10
        # Use ollama list to check if server is ready (retries built-in)
        until ollama list 2>/dev/null; do
          echo "Ollama not ready, retrying..."
          sleep 5
        done
        echo "Ollama server ready, pulling tinyllama..."
        ollama pull tinyllama
        echo "tinyllama model ready!"
    depends_on:
      - ai-ollama
    restart: "no"

  # Qdrant vector database for AI memory and research
  infra-qdrant:
    image: qdrant/qdrant:latest
    container_name: infra-qdrant
    volumes:
      - qdrant-data:/qdrant/storage
    networks:
      - waddlebot-internal
    # Port removed - internal only, accessed by ai-researcher
    # ports:
    #   - "6333:6333"
    healthcheck:
      test: ["CMD-SHELL", "bash -c '</dev/tcp/localhost/6333'"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped

  # Apache OpenWhisk standalone for testing serverless actions
  # NOTE: Disabled on ARM64 - openwhisk/standalone:nightly lacks native ARM64 support
  # x86_64 emulation on ARM64 (linux/amd64) fails with exit code 255 (platform mismatch)
  # Enable this service only on native amd64 systems
  # openwhisk:
  #   image: openwhisk/standalone:nightly
  #   container_name: waddlebot-openwhisk
  #   platform: linux/amd64
  #   ports:
  #     - "3233:3233"   # OpenWhisk API
  #   environment:
  #     JAVA_OPTS: "-Xmx1g"
  #   volumes:
  #     - /var/run/docker.sock:/var/run/docker.sock
  #   networks:
  #     - waddlebot-public
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:3233/api/v1"]
  #     interval: 30s
  #     timeout: 10s
  #     start_period: 120s
  #     retries: 10
  #   restart: unless-stopped

  # =============================================================================
  # KONG API GATEWAY - Single external entry point for all APIs
  # Access via api.waddlebot.io - No direct access to internal services
  # Kong Manager OSS GUI available at http://localhost:8002/manager
  # Note: Kong is docker-compose only. Kubernetes uses Nginx Ingress Controller.
  # =============================================================================

  core-kong:
    image: kong:3.5-ubuntu
    container_name: core-kong
    environment:
      KONG_DATABASE: postgres
      KONG_PG_HOST: infra-postgres
      KONG_PG_PORT: 5432
      KONG_PG_DATABASE: kong
      KONG_PG_USER: kong
      KONG_PG_PASSWORD: ${KONG_PG_PASSWORD}
      KONG_PROXY_ACCESS_LOG: /dev/stdout
      KONG_ADMIN_ACCESS_LOG: /dev/stdout
      KONG_PROXY_ERROR_LOG: /dev/stderr
      KONG_ADMIN_ERROR_LOG: /dev/stderr
      KONG_ADMIN_LISTEN: "0.0.0.0:8012"
      KONG_PROXY_LISTEN: "0.0.0.0:8080, 0.0.0.0:8443 ssl"
      # Kong Manager OSS configuration
      KONG_ADMIN_GUI_PATH: /manager
      KONG_ADMIN_GUI_URL: http://localhost:8012/manager
      KONG_ADMIN_GUI_AUTH: basic-auth
      KONG_ADMIN_GUI_SESSION_CONF: '{"secret":"${KONG_SESSION_SECRET}","storage":"kong","cookie_secure":false,"cookie_samesite":"Lax"}'
      KONG_ENFORCE_RBAC: "on"
      # SSL certificates (mount your own in production)
      # KONG_SSL_CERT: /etc/kong/ssl/api.waddlebot.io.crt
      # KONG_SSL_CERT_KEY: /etc/kong/ssl/api.waddlebot.io.key
    volumes:
      - ./config/kong/ssl:/etc/kong/ssl:ro
    ports:
      - "8080:8080"   # Kong HTTP API (api.waddlebot.io)
      - "8443:8443"   # Kong HTTPS API
      - "127.0.0.1:8001:8001"  # Kong Admin API (localhost only for security)
      - "8012:8012"   # Kong Manager OSS GUI
    networks:
      - waddlebot-public
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
      hub-api:
        condition: service_started
      core-router:
        condition: service_started
    healthcheck:
      test: ["CMD", "kong", "health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # =============================================================================
  # CORE MODULES
  # =============================================================================

  core-router:
    build:
      context: .
      dockerfile: processing/router_module/Dockerfile
    container_name: core-router
    environment:
      MODULE_NAME: router
      MODULE_PORT: 8000
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      # Redis ACL: user=router, prefix=router:*, waddlebot:session:*, waddlebot:rate:*, waddlebot:cmd:*
      REDIS_URL: redis://router:${REDIS_ROUTER_PASSWORD}@infra-redis:6379/0
      REDIS_KEY_PREFIX: "router:"
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
      infra-redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # marketplace service removed - functionality now in hub admin panel

  hub-api:
    build:
      context: .
      dockerfile: admin/hub_module/Dockerfile
    container_name: hub-api
    environment:
      NODE_ENV: ${NODE_ENV}
      PORT: 8060
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      # Redis ACL: user=hub, prefix=hub:*, waddlebot:session:*, waddlebot:auth:*
      REDIS_URL: redis://hub:${REDIS_HUB_PASSWORD}@infra-redis:6379/0
      REDIS_KEY_PREFIX: "hub:"
      JWT_SECRET: ${JWT_SECRET}
      BASE_DOMAIN: ${BASE_DOMAIN}
      # OAuth Configuration
      DISCORD_CLIENT_ID: ${DISCORD_CLIENT_ID}
      DISCORD_CLIENT_SECRET: ${DISCORD_CLIENT_SECRET}
      TWITCH_CLIENT_ID: ${TWITCH_CLIENT_ID}
      TWITCH_CLIENT_SECRET: ${TWITCH_CLIENT_SECRET}
      SLACK_CLIENT_ID: ${SLACK_CLIENT_ID}
      SLACK_CLIENT_SECRET: ${SLACK_CLIENT_SECRET}
      # Internal service URLs
      ROUTER_API_URL: http://core-router:8000
      IDENTITY_API_URL: http://core-identity:8050
      INVENTORY_API_URL: http://interactive-inventory:8024
      REPUTATION_API_URL: http://core-reputation:8021
      CALENDAR_API_URL: http://interactive-calendar:8030
      MEMORIES_API_URL: http://interactive-memories:8031
      LABELS_API_URL: http://core-labels:8023
      SHOUTOUT_API_URL: http://interactive-shoutout:8011
      BROWSER_SOURCE_API_URL: http://core-browser-source:8027
      LOYALTY_API_URL: http://interactive-loyalty:8032
      # Overlay Configuration
      OVERLAY_BASE_URL: ${OVERLAY_BASE_URL}
      # S3 Storage Configuration (MinIO)
      S3_STORAGE_ENABLED: "true"
      S3_BUCKET_NAME: waddlebot-assets
      S3_ENDPOINT_URL: http://minio:9000
      S3_ACCESS_KEY_ID: ${MINIO_ROOT_USER}
      S3_SECRET_ACCESS_KEY: ${MINIO_ROOT_PASSWORD}
      S3_PUBLIC_BASE_URL: http://localhost:9000/waddlebot-assets
      LOG_LEVEL: ${LOG_LEVEL}
    ports:
      - "8060:8060"  # Hub admin portal
    networks:
      - waddlebot-public
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
      infra-redis:
        condition: service_healthy
      infra-minio:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://127.0.0.1:8060/health"]
      interval: 30s
      timeout: 10s
      start_period: 30s
      retries: 5
    restart: unless-stopped

  # =============================================================================
  # COLLECTOR MODULES (Internal)
  # =============================================================================

  trigger-twitch:
    build:
      context: .
      dockerfile: trigger/receiver/twitch_module/Dockerfile
    container_name: trigger-twitch
    environment:
      MODULE_NAME: twitch-collector
      MODULE_PORT: 8002
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      TWITCH_CLIENT_ID: ${TWITCH_CLIENT_ID}
      TWITCH_CLIENT_SECRET: ${TWITCH_CLIENT_SECRET}
      TWITCH_WEBHOOK_SECRET: ${TWITCH_WEBHOOK_SECRET}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8002/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  trigger-discord:
    build:
      context: .
      dockerfile: trigger/receiver/discord_module/Dockerfile
    container_name: trigger-discord
    environment:
      MODULE_NAME: discord-collector
      MODULE_PORT: 8003
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      DISCORD_BOT_TOKEN: ${DISCORD_BOT_TOKEN}
      DISCORD_APPLICATION_ID: ${DISCORD_APPLICATION_ID}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8003/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  trigger-slack:
    build:
      context: .
      dockerfile: trigger/receiver/slack_module/Dockerfile
    container_name: trigger-slack
    environment:
      MODULE_NAME: slack-collector
      MODULE_PORT: 8004
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      SLACK_BOT_TOKEN: ${SLACK_BOT_TOKEN}
      SLACK_SIGNING_SECRET: ${SLACK_SIGNING_SECRET}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8004/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  trigger-youtube:
    build:
      context: .
      dockerfile: trigger/receiver/youtube_live_module/Dockerfile
    container_name: trigger-youtube
    environment:
      MODULE_NAME: youtube-live-collector
      MODULE_PORT: 8006
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      YOUTUBE_API_KEY: ${YOUTUBE_API_KEY}
      YOUTUBE_CLIENT_ID: ${YOUTUBE_CLIENT_ID}
      YOUTUBE_CLIENT_SECRET: ${YOUTUBE_CLIENT_SECRET}
      YOUTUBE_WEBHOOK_CALLBACK_URL: ${YOUTUBE_WEBHOOK_CALLBACK_URL}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8006/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  trigger-kick:
    build:
      context: .
      dockerfile: trigger/receiver/kick_module_flask/Dockerfile
    container_name: trigger-kick
    environment:
      MODULE_NAME: kick-collector
      MODULE_PORT: 8007
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      KICK_CLIENT_ID: ${KICK_CLIENT_ID}
      KICK_CLIENT_SECRET: ${KICK_CLIENT_SECRET}
      KICK_WEBHOOK_SECRET: ${KICK_WEBHOOK_SECRET}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8007/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # =============================================================================
  # INTERACTION MODULES (Internal)
  # =============================================================================

  interactive-ai:
    build:
      context: .
      dockerfile: action/interactive/ai_interaction_module/Dockerfile
    container_name: interactive-ai
    environment:
      MODULE_NAME: ai-interaction
      MODULE_PORT: 8005
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      AI_PROVIDER: ${AI_PROVIDER}
      OLLAMA_HOST: ${OLLAMA_HOST}
      OLLAMA_PORT: ${OLLAMA_PORT}
      OLLAMA_USE_TLS: ${OLLAMA_USE_TLS}
      OLLAMA_MODEL: ${OLLAMA_MODEL}  # Multilingual model for language detection
      WADDLEAI_BASE_URL: ${WADDLEAI_BASE_URL}
      WADDLEAI_API_KEY: ${WADDLEAI_API_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - ai-ollama
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8005/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  interactive-alias:
    build:
      context: .
      dockerfile: action/interactive/alias_interaction_module/Dockerfile
    container_name: interactive-alias
    environment:
      MODULE_NAME: alias-interaction
      MODULE_PORT: 8010
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8010/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  interactive-shoutout:
    build:
      context: .
      dockerfile: action/interactive/shoutout_interaction_module/Dockerfile
    container_name: interactive-shoutout
    environment:
      MODULE_NAME: shoutout-interaction
      MODULE_PORT: 8011
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8011/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  interactive-inventory:
    build:
      context: .
      dockerfile: action/interactive/inventory_interaction_module/Dockerfile
    container_name: interactive-inventory
    environment:
      MODULE_NAME: inventory-interaction
      MODULE_PORT: 8024
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8024/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  interactive-calendar:
    build:
      context: .
      dockerfile: action/interactive/calendar_interaction_module/Dockerfile
    container_name: interactive-calendar
    environment:
      MODULE_NAME: calendar-interaction
      MODULE_PORT: 8030
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8030/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  interactive-memories:
    build:
      context: .
      dockerfile: action/interactive/memories_interaction_module/Dockerfile
    container_name: interactive-memories
    environment:
      MODULE_NAME: memories-interaction
      MODULE_PORT: 8031
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8031/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  interactive-youtube-music:
    build:
      context: .
      dockerfile: action/interactive/youtube_music_interaction_module/Dockerfile
    container_name: interactive-youtube-music
    environment:
      MODULE_NAME: youtube-music
      MODULE_PORT: 8025
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      BROWSER_SOURCE_API_URL: http://core-browser-source:8027
      YOUTUBE_API_KEY: ${YOUTUBE_API_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - core-browser-source
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8025/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  interactive-spotify:
    build:
      context: .
      dockerfile: action/interactive/spotify_interaction_module/Dockerfile
    container_name: interactive-spotify
    environment:
      MODULE_NAME: spotify-interaction
      MODULE_PORT: 8026
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      BROWSER_SOURCE_API_URL: http://core-browser-source:8027
      SPOTIFY_CLIENT_ID: ${SPOTIFY_CLIENT_ID}
      SPOTIFY_CLIENT_SECRET: ${SPOTIFY_CLIENT_SECRET}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - core-browser-source
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8026/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  interactive-loyalty:
    build:
      context: .
      dockerfile: action/interactive/loyalty_interaction_module/Dockerfile
    container_name: interactive-loyalty
    environment:
      MODULE_NAME: loyalty-interaction
      MODULE_PORT: 8032
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      REPUTATION_API_URL: http://core-reputation:8021
      SERVICE_API_KEY: ${SERVICE_API_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - infra-postgres
      - core-router
      - core-reputation
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8032/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # =============================================================================
  # CORE SYSTEM MODULES (Internal)
  # =============================================================================

  core-labels:
    build:
      context: .
      dockerfile: core/labels_core_module/Dockerfile
    container_name: core-labels
    environment:
      MODULE_NAME: labels-core
      MODULE_PORT: 8023
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      # Redis ACL: uses router credentials for shared cache access
      REDIS_URL: redis://router:${REDIS_ROUTER_PASSWORD}@infra-redis:6379/0
      REDIS_KEY_PREFIX: "labels:"
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - infra-redis
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8023/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  core-browser-source:
    build:
      context: .
      dockerfile: core/browser_source_core_module/Dockerfile
    container_name: core-browser-source
    environment:
      MODULE_NAME: browser-source
      MODULE_PORT: 8027
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      OVERLAY_BASE_URL: ${OVERLAY_BASE_URL}
      OVERLAY_KEY_GRACE_PERIOD_MINUTES: ${OVERLAY_KEY_GRACE_PERIOD_MINUTES}
      LOG_LEVEL: ${LOG_LEVEL}
    ports:
      - "8027:8027"  # Browser sources need direct access from OBS
    networks:
      - waddlebot-public
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8027/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  core-identity:
    build:
      context: .
      dockerfile: core/identity_core_module/Dockerfile
    container_name: core-identity
    environment:
      MODULE_NAME: identity-core
      MODULE_PORT: 8050
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      # Redis ACL: uses hub credentials for session/auth data
      REDIS_URL: redis://hub:${REDIS_HUB_PASSWORD}@infra-redis:6379/0
      REDIS_KEY_PREFIX: "identity:"
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - infra-redis
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8050/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  ai-researcher:
    build:
      context: .
      dockerfile: core/ai_researcher_module/Dockerfile
    container_name: ai-researcher
    environment:
      MODULE_NAME: ai_researcher_module
      MODULE_VERSION: 1.0.0
      MODULE_PORT: 8070
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      # Redis ACL: user=ai_researcher, prefix=ai:*, waddlebot:ai:*, waddlebot:rate:ai:*
      REDIS_URL: redis://ai_researcher:${REDIS_AI_PASSWORD}@infra-redis:6379/0
      REDIS_KEY_PREFIX: "ai:"
      ROUTER_API_URL: http://core-router:8000/api/v1/router
      OLLAMA_HOST: ${OLLAMA_HOST}
      OLLAMA_PORT: ${OLLAMA_PORT}
      AI_PROVIDER: ${AI_PROVIDER}
      AI_MODEL: ${OLLAMA_MODEL}
      MEM0_VECTOR_STORE: ${MEM0_VECTOR_STORE}
      QDRANT_URL: ${QDRANT_URL}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
      infra-redis:
        condition: service_healthy
      infra-qdrant:
        condition: service_healthy
    # Port removed - access via Kong at api.waddlebot.io
    # ports:
    #   - "8070:8070"
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8070/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  core-workflow:
    build:
      context: .
      dockerfile: core/workflow_core_module/Dockerfile
    container_name: core-workflow
    environment:
      MODULE_NAME: workflow-core
      MODULE_PORT: 8090
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      # Redis ACL: user=workflow, prefix=workflow:*, waddlebot:jobs:*, waddlebot:schedule:*, waddlebot:lock:*
      REDIS_URL: redis://workflow:${REDIS_WORKFLOW_PASSWORD}@infra-redis:6379/0
      REDIS_KEY_PREFIX: "workflow:"
      ROUTER_API_URL: http://core-router:8000
      LICENSE_SERVER_URL: ${LICENSE_SERVER_URL}
      RELEASE_MODE: ${RELEASE_MODE}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
      infra-redis:
        condition: service_healthy
      core-router:
        condition: service_started
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8070/health')"]
      interval: 30s
      timeout: 10s
      start_period: 30s
      retries: 5
    restart: unless-stopped

  # =============================================================================
  # SUPPORTING MODULES (Internal)
  # =============================================================================

  core-community:
    build:
      context: .
      dockerfile: core/community_module/Dockerfile
    container_name: core-community
    environment:
      MODULE_NAME: community
      MODULE_PORT: 8020
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8020/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  core-reputation:
    build:
      context: .
      dockerfile: core/reputation_module/Dockerfile
    container_name: core-reputation
    environment:
      MODULE_NAME: reputation
      MODULE_PORT: 8021
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      ROUTER_API_URL: http://core-router:8000
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8021/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  core-analytics:
    build:
      context: .
      dockerfile: core/analytics_core_module/Dockerfile
    container_name: core-analytics
    environment:
      MODULE_NAME: analytics-core
      MODULE_PORT: 8040
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      # Redis ACL: user=analytics, prefix=analytics:*, waddlebot:metrics:*, waddlebot:counters:*
      REDIS_URL: redis://analytics:${REDIS_ANALYTICS_PASSWORD}@infra-redis:6379/0
      REDIS_KEY_PREFIX: "analytics:"
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
      infra-redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8040/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  core-security:
    build:
      context: .
      dockerfile: core/security_core_module/Dockerfile
    container_name: core-security
    environment:
      MODULE_NAME: security-core
      MODULE_PORT: 8041
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      # Redis ACL: user=security, prefix=security:*, waddlebot:blacklist:*, waddlebot:threat:*
      REDIS_URL: redis://security:${REDIS_SECURITY_PASSWORD}@infra-redis:6379/0
      REDIS_KEY_PREFIX: "security:"
      REPUTATION_API_URL: http://core-reputation:8021
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
      infra-redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8041/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # =============================================================================
  # PUSHING ACTION MODULES (Platform Integration)
  # =============================================================================

  action-discord:
    build:
      context: .
      dockerfile: action/pushing/discord_action_module/Dockerfile
    container_name: action-discord
    environment:
      MODULE_NAME: discord-action
      GRPC_PORT: 50051
      REST_PORT: 8070
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      DISCORD_BOT_TOKEN: ${DISCORD_BOT_TOKEN}
      MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - infra-postgres
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8070/health')"]
      interval: 30s
      timeout: 10s
      start_period: 20s
      retries: 5
    restart: unless-stopped

  action-slack:
    build:
      context: .
      dockerfile: action/pushing/slack_action_module/Dockerfile
    container_name: action-slack
    environment:
      MODULE_NAME: slack-action
      GRPC_PORT: 50052
      REST_PORT: 8071
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      SLACK_BOT_TOKEN: ${SLACK_BOT_TOKEN}
      MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - infra-postgres
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8071/health')"]
      interval: 30s
      timeout: 10s
      start_period: 20s
      retries: 5
    restart: unless-stopped

  action-twitch:
    build:
      context: .
      dockerfile: action/pushing/twitch_action_module/Dockerfile
    container_name: action-twitch
    environment:
      MODULE_NAME: twitch-action
      GRPC_PORT: 50053
      REST_PORT: 8072
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      TWITCH_CLIENT_ID: ${TWITCH_CLIENT_ID}
      TWITCH_CLIENT_SECRET: ${TWITCH_CLIENT_SECRET}
      MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - infra-postgres
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8072/health')"]
      interval: 30s
      timeout: 10s
      start_period: 20s
      retries: 5
    restart: unless-stopped

  action-youtube:
    build:
      context: .
      dockerfile: action/pushing/youtube_action_module/Dockerfile
    container_name: action-youtube
    environment:
      MODULE_NAME: youtube-action
      GRPC_PORT: 50054
      REST_PORT: 8073
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      YOUTUBE_API_KEY: ${YOUTUBE_API_KEY}
      YOUTUBE_CLIENT_ID: ${YOUTUBE_CLIENT_ID}
      YOUTUBE_CLIENT_SECRET: ${YOUTUBE_CLIENT_SECRET}
      MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - infra-postgres
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8073/health')"]
      interval: 30s
      timeout: 10s
      start_period: 20s
      retries: 5
    restart: unless-stopped

  # =============================================================================
  # VIDEO & ENGAGEMENT MODULES
  # =============================================================================

  core-video-proxy:
    build:
      context: .
      dockerfile: core/video_proxy_module/Dockerfile
    container_name: core-video-proxy
    environment:
      MODULE_NAME: video-proxy
      MODULE_PORT: 8092
      GRPC_PORT: 50065
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      MARCHPROXY_GRPC_HOST: marchproxy-rtmp
      MARCHPROXY_GRPC_PORT: 50050
      MINIO_ENDPOINT: infra-minio:9000
      MINIO_ACCESS_KEY: ${MINIO_ROOT_USER}
      MINIO_SECRET_KEY: ${MINIO_ROOT_PASSWORD}
      MINIO_BUCKET: video-proxy
      LICENSE_SERVER_URL: ${LICENSE_SERVER_URL}
      RELEASE_MODE: ${RELEASE_MODE}
      JWT_SECRET_KEY: ${JWT_SECRET}
      MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
      infra-minio:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8092/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  core-engagement:
    build:
      context: .
      dockerfile: core/engagement_module/Dockerfile
    container_name: core-engagement
    environment:
      MODULE_NAME: engagement
      MODULE_PORT: 8091
      GRPC_PORT: 50066
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      JWT_SECRET_KEY: ${JWT_SECRET}
      MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8091/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  core-module-rtc:
    build:
      context: ./core/module_rtc
      dockerfile: Dockerfile
    container_name: core-module-rtc
    environment:
      MODULE_NAME: module-rtc
      MODULE_PORT: 8093
      GRPC_PORT: 50067
      LIVEKIT_HOST: ${LIVEKIT_HOST:-livekit:7880}
      LIVEKIT_API_KEY: ${LIVEKIT_API_KEY}
      LIVEKIT_API_SECRET: ${LIVEKIT_API_SECRET}
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      HUB_API_URL: http://hub-api:8060
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      infra-postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8093/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # MarchProxy RTMP sidecar for video proxy
  marchproxy-rtmp:
    image: ghcr.io/penguintech/marchproxy:latest
    container_name: marchproxy-rtmp
    environment:
      MARCHPROXY_MODE: rtmp
      MARCHPROXY_GRPC_PORT: 50050
      MARCHPROXY_RTMP_PORT: 1935
    ports:
      - "1935:1935"  # RTMP ingest
    networks:
      - waddlebot-internal
      - waddlebot-public
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    restart: unless-stopped

  # =============================================================================
  # SERVERLESS PLATFORM ACTION MODULES
  # =============================================================================

  action-lambda:
    build:
      context: .
      dockerfile: action/pushing/lambda_action_module/Dockerfile
    container_name: action-lambda
    environment:
      MODULE_NAME: lambda-action
      GRPC_PORT: 50060
      REST_PORT: 8080
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
      AWS_REGION: ${AWS_REGION}
      AWS_LAMBDA_ROLE_ARN: ${AWS_LAMBDA_ROLE_ARN}
      MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - infra-postgres
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8080/health')"]
      interval: 30s
      timeout: 10s
      start_period: 20s
      retries: 5
    restart: unless-stopped

  action-gcp-functions:
    build:
      context: .
      dockerfile: action/pushing/gcp_functions_action_module/Dockerfile
    container_name: action-gcp-functions
    environment:
      MODULE_NAME: gcp-functions-action
      GRPC_PORT: 50061
      REST_PORT: 8081
      DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
      GCP_PROJECT_ID: ${GCP_PROJECT_ID}
      GCP_REGION: ${GCP_REGION}
      GCP_SERVICE_ACCOUNT_KEY: ${GCP_SERVICE_ACCOUNT_KEY}
      GCP_SERVICE_ACCOUNT_EMAIL: ${GCP_SERVICE_ACCOUNT_EMAIL}
      MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
      LOG_LEVEL: ${LOG_LEVEL}
    networks:
      - waddlebot-internal
    depends_on:
      - core-router
      - infra-postgres
    healthcheck:
      test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8081/health')"]
      interval: 30s
      timeout: 10s
      start_period: 20s
      retries: 5
    restart: unless-stopped

  # OpenWhisk action module disabled - requires native ARM64 OpenWhisk image
  # Re-enable when ARM64-compatible OpenWhisk image available
  # openwhisk-action:
  #   build:
  #     context: .
  #     dockerfile: action/pushing/openwhisk_action_module/Dockerfile
  #   container_name: waddlebot-openwhisk-action
  #   environment:
  #     MODULE_NAME: openwhisk-action
  #     GRPC_PORT: 50062
  #     REST_PORT: 8082
  #     DATABASE_URL: postgresql://waddlebot:${POSTGRES_PASSWORD}@infra-postgres:5432/waddlebot
  #     OPENWHISK_API_HOST: ${OPENWHISK_API_HOST}
  #     OPENWHISK_AUTH_KEY: ${OPENWHISK_AUTH_KEY}
  #     OPENWHISK_NAMESPACE: ${OPENWHISK_NAMESPACE}
  #     OPENWHISK_INSECURE: ${OPENWHISK_INSECURE}
  #     MODULE_SECRET_KEY: ${MODULE_SECRET_KEY}
  #     LOG_LEVEL: ${LOG_LEVEL}
  #   networks:
  #     - waddlebot-internal
  #     - waddlebot-public
  #   depends_on:
  #     - core-router
  #     - infra-postgres
  #     - openwhisk
  #   healthcheck:
  #     test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8082/health')"]
  #     interval: 30s
  #     timeout: 10s
  #     retries: 3
  #   restart: unless-stopped
